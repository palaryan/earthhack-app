{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport AccessibilityUtil from \"../../modules/AccessibilityUtil\";\nimport BoundingDimensions from \"./BoundingDimensions\";\nimport findNodeHandle from \"../findNodeHandle\";\nimport normalizeColor from 'normalize-css-color';\nimport Position from \"./Position\";\nimport React from 'react';\nimport TouchEventUtils from 'fbjs/lib/TouchEventUtils';\nimport UIManager from \"../UIManager\";\nimport View from \"../View\";\nvar States = {\n  NOT_RESPONDER: 'NOT_RESPONDER',\n  RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',\n  RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',\n  RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',\n  RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',\n  RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',\n  ERROR: 'ERROR'\n};\nvar IsActive = {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n};\nvar IsPressingIn = {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\nvar IsLongPressingIn = {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\nvar Signals = {\n  DELAY: 'DELAY',\n  RESPONDER_GRANT: 'RESPONDER_GRANT',\n  RESPONDER_RELEASE: 'RESPONDER_RELEASE',\n  RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',\n  ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',\n  LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',\n  LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'\n};\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\n  }\n};\nvar HIGHLIGHT_DELAY_MS = 130;\nvar PRESS_EXPAND_PX = 20;\nvar LONG_PRESS_THRESHOLD = 500;\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10;\nvar TouchableMixin = {\n  componentDidMount: function componentDidMount() {\n    var _this = this;\n\n    this._touchableNode = findNodeHandle(this);\n\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableBlurListener = function (e) {\n        if (_this._isTouchableKeyboardActive) {\n          if (_this.state.touchable.touchState && _this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            _this.touchableHandleResponderTerminate({\n              nativeEvent: e\n            });\n          }\n\n          _this._isTouchableKeyboardActive = false;\n        }\n      };\n\n      this._touchableNode.addEventListener('blur', this._touchableBlurListener);\n    }\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableNode.removeEventListener('blur', this._touchableBlurListener);\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n  },\n  touchableGetInitialState: function touchableGetInitialState() {\n    return {\n      touchable: {\n        touchState: undefined,\n        responderID: null\n      }\n    };\n  },\n  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {\n    return !this.props.rejectResponderTermination;\n  },\n  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {\n    return !this.props.disabled;\n  },\n  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {\n    return true;\n  },\n  touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {\n    var dispatchID = e.currentTarget;\n    e.persist();\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressOutDelayTimeout = null;\n    this.state.touchable.touchState = States.NOT_RESPONDER;\n    this.state.touchable.responderID = dispatchID;\n\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\n\n    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n\n    if (delayMS !== 0) {\n      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);\n    } else {\n      this.state.touchable.positionOnActivate = null;\n\n      this._handleDelay(e);\n    }\n\n    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);\n  },\n  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n  },\n  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n  },\n  touchableHandleResponderMove: function touchableHandleResponderMove(e) {\n    if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {\n      return;\n    }\n\n    if (!this.state.touchable.positionOnActivate) {\n      return;\n    }\n\n    var positionOnActivate = this.state.touchable.positionOnActivate;\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {\n      left: PRESS_EXPAND_PX,\n      right: PRESS_EXPAND_PX,\n      top: PRESS_EXPAND_PX,\n      bottom: PRESS_EXPAND_PX\n    };\n    var pressExpandLeft = pressRectOffset.left;\n    var pressExpandTop = pressRectOffset.top;\n    var pressExpandRight = pressRectOffset.right;\n    var pressExpandBottom = pressRectOffset.bottom;\n    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;\n\n    if (hitSlop) {\n      pressExpandLeft += hitSlop.left;\n      pressExpandTop += hitSlop.top;\n      pressExpandRight += hitSlop.right;\n      pressExpandBottom += hitSlop.bottom;\n    }\n\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n\n    if (this.pressInLocation) {\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n        this._cancelLongPressDelayTimeout();\n      }\n    }\n\n    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;\n\n    if (isTouchWithinActive) {\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n\n      var curState = this.state.touchable.touchState;\n\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {\n        this._cancelLongPressDelayTimeout();\n      }\n    } else {\n      this._cancelLongPressDelayTimeout();\n\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n    }\n  },\n  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {\n    var tag = this.state.touchable.responderID;\n\n    if (tag == null) {\n      return;\n    }\n\n    UIManager.measure(tag, this._handleQueryLayout);\n  },\n  _handleQueryLayout: function _handleQueryLayout(x, y, width, height, globalX, globalY) {\n    if (!x && !y && !width && !height && !globalX && !globalY) {\n      return;\n    }\n\n    this.state.touchable.positionOnActivate && Position.release(this.state.touchable.positionOnActivate);\n    this.state.touchable.dimensionsOnActivate && BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);\n    this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY);\n    this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(width, height);\n  },\n  _handleDelay: function _handleDelay(e) {\n    this.touchableDelayTimeout = null;\n\n    this._receiveSignal(Signals.DELAY, e);\n  },\n  _handleLongDelay: function _handleLongDelay(e) {\n    this.longPressDelayTimeout = null;\n    var curState = this.state.touchable.touchState;\n\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n      console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n    } else {\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n    }\n  },\n  _receiveSignal: function _receiveSignal(signal, e) {\n    var responderID = this.state.touchable.responderID;\n    var curState = this.state.touchable.touchState;\n    var nextState = Transitions[curState] && Transitions[curState][signal];\n\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (!nextState) {\n      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');\n    }\n\n    if (nextState === States.ERROR) {\n      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');\n    }\n\n    if (curState !== nextState) {\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\n\n      this.state.touchable.touchState = nextState;\n    }\n  },\n  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.longPressDelayTimeout = null;\n  },\n  _isHighlight: function _isHighlight(state) {\n    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n  },\n  _savePressInLocation: function _savePressInLocation(e) {\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    this.pressInLocation = {\n      pageX: pageX,\n      pageY: pageY,\n\n      get locationX() {\n        return touch && touch.locationX;\n      },\n\n      get locationY() {\n        return touch && touch.locationY;\n      }\n\n    };\n  },\n  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\n    var deltaX = aX - bX;\n    var deltaY = aY - bY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  },\n  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {\n    var curIsHighlight = this._isHighlight(curState);\n\n    var newIsHighlight = this._isHighlight(nextState);\n\n    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\n\n    if (isFinalSignal) {\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (!IsActive[curState] && IsActive[nextState]) {\n      this._remeasureMetricsOnActivation();\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n    }\n\n    if (newIsHighlight && !curIsHighlight) {\n      this._startHighlight(e);\n    } else if (!newIsHighlight && curIsHighlight) {\n      this._endHighlight(e);\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n      var hasLongPressHandler = !!this.props.onLongPress;\n      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (!hasLongPressHandler || !this.touchableLongPressCancelsPress());\n      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n\n      if (shouldInvokePress && this.touchableHandlePress) {\n        if (!newIsHighlight && !curIsHighlight) {\n          this._startHighlight(e);\n\n          this._endHighlight(e);\n        }\n\n        this.touchableHandlePress(e);\n      }\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.touchableDelayTimeout = null;\n  },\n  _startHighlight: function _startHighlight(e) {\n    this._savePressInLocation(e);\n\n    this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n  },\n  _endHighlight: function _endHighlight(e) {\n    var _this2 = this;\n\n    if (this.touchableHandleActivePressOut) {\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n        this.pressOutDelayTimeout = setTimeout(function () {\n          _this2.touchableHandleActivePressOut(e);\n        }, this.touchableGetPressOutDelayMS());\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n  },\n  touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {\n    var ENTER = 13;\n    var SPACE = 32;\n    var type = e.type,\n        which = e.which;\n\n    if (which === ENTER || which === SPACE) {\n      if (type === 'keydown') {\n        if (!this._isTouchableKeyboardActive) {\n          if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {\n            this.touchableHandleResponderGrant(e);\n            this._isTouchableKeyboardActive = true;\n          }\n        }\n      } else if (type === 'keyup') {\n        if (this._isTouchableKeyboardActive) {\n          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            this.touchableHandleResponderRelease(e);\n            this._isTouchableKeyboardActive = false;\n          }\n        }\n      }\n\n      e.stopPropagation();\n\n      if (!(which === ENTER && AccessibilityUtil.propsToAriaRole(this.props) === 'link')) {\n        e.preventDefault();\n      }\n    }\n  }\n};\nvar Touchable = {\n  Mixin: TouchableMixin,\n  TOUCH_TARGET_DEBUG: false,\n  renderDebugView: function renderDebugView(_ref) {\n    var color = _ref.color,\n        hitSlop = _ref.hitSlop;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Touchable.TOUCH_TARGET_DEBUG) {\n        return null;\n      }\n\n      var debugHitSlopStyle = {};\n      hitSlop = hitSlop || {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0\n      };\n\n      for (var key in hitSlop) {\n        debugHitSlopStyle[key] = -hitSlop[key];\n      }\n\n      var hexColor = '#' + ('00000000' + normalizeColor(color).toString(16)).substr(-8);\n      return React.createElement(View, {\n        pointerEvents: \"none\",\n        style: _objectSpread({\n          position: 'absolute',\n          borderColor: hexColor.slice(0, -2) + '55',\n          borderWidth: 1,\n          borderStyle: 'dashed',\n          backgroundColor: hexColor.slice(0, -2) + '0F'\n        }, debugHitSlopStyle)\n      });\n    }\n  }\n};\nexport default Touchable;","map":{"version":3,"sources":["C:/Users/aryan/Documents/GitHub/earthhack-app/node_modules/react-native-web/dist/exports/Touchable/index.js"],"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","AccessibilityUtil","BoundingDimensions","findNodeHandle","normalizeColor","Position","React","TouchEventUtils","UIManager","View","States","NOT_RESPONDER","RESPONDER_INACTIVE_PRESS_IN","RESPONDER_INACTIVE_PRESS_OUT","RESPONDER_ACTIVE_PRESS_IN","RESPONDER_ACTIVE_PRESS_OUT","RESPONDER_ACTIVE_LONG_PRESS_IN","RESPONDER_ACTIVE_LONG_PRESS_OUT","ERROR","IsActive","IsPressingIn","IsLongPressingIn","Signals","DELAY","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","ENTER_PRESS_RECT","LEAVE_PRESS_RECT","LONG_PRESS_DETECTED","Transitions","error","HIGHLIGHT_DELAY_MS","PRESS_EXPAND_PX","LONG_PRESS_THRESHOLD","LONG_PRESS_DELAY_MS","LONG_PRESS_ALLOWED_MOVEMENT","TouchableMixin","componentDidMount","_this","_touchableNode","addEventListener","_touchableBlurListener","e","_isTouchableKeyboardActive","state","touchable","touchState","touchableHandleResponderTerminate","nativeEvent","componentWillUnmount","removeEventListener","touchableDelayTimeout","clearTimeout","longPressDelayTimeout","pressOutDelayTimeout","touchableGetInitialState","undefined","responderID","touchableHandleResponderTerminationRequest","props","rejectResponderTermination","touchableHandleStartShouldSetResponder","disabled","touchableLongPressCancelsPress","touchableHandleResponderGrant","dispatchID","currentTarget","persist","_receiveSignal","delayMS","touchableGetHighlightDelayMS","Math","max","isNaN","setTimeout","_handleDelay","bind","positionOnActivate","longDelayMS","touchableGetLongPressDelayMS","_handleLongDelay","touchableHandleResponderRelease","touchableHandleResponderMove","dimensionsOnActivate","pressRectOffset","touchableGetPressRectOffset","left","right","top","bottom","pressExpandLeft","pressExpandTop","pressExpandRight","pressExpandBottom","hitSlop","touchableGetHitSlop","touch","extractSingleTouch","pageX","pageY","pressInLocation","movedDistance","_getDistanceBetweenPoints","_cancelLongPressDelayTimeout","isTouchWithinActive","width","height","curState","_remeasureMetricsOnActivation","tag","measure","_handleQueryLayout","x","y","globalX","globalY","release","getPooled","console","signal","nextState","Error","_performSideEffectsForTransition","_isHighlight","_savePressInLocation","locationX","locationY","aX","aY","bX","bY","deltaX","deltaY","sqrt","curIsHighlight","newIsHighlight","isFinalSignal","touchableHandleLongPress","_startHighlight","_endHighlight","hasLongPressHandler","onLongPress","pressIsLongButStillCallOnPress","shouldInvokePress","touchableHandlePress","touchableHandleActivePressIn","_this2","touchableHandleActivePressOut","touchableGetPressOutDelayMS","touchableHandleKeyEvent","ENTER","SPACE","type","which","stopPropagation","propsToAriaRole","preventDefault","Touchable","Mixin","TOUCH_TARGET_DEBUG","renderDebugView","_ref","color","process","env","NODE_ENV","debugHitSlopStyle","hexColor","toString","substr","createElement","pointerEvents","style","position","borderColor","slice","borderWidth","borderStyle","backgroundColor"],"mappings":"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","sourcesContent":["function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\n/* eslint-disable react/prop-types */\r\n\r\n/**\r\n * Copyright (c) Nicolas Gallagher.\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\r\nimport AccessibilityUtil from '../../modules/AccessibilityUtil';\r\nimport BoundingDimensions from './BoundingDimensions';\r\nimport findNodeHandle from '../findNodeHandle';\r\nimport normalizeColor from 'normalize-css-color';\r\nimport Position from './Position';\r\nimport React from 'react';\r\nimport TouchEventUtils from 'fbjs/lib/TouchEventUtils';\r\nimport UIManager from '../UIManager';\r\nimport View from '../View';\r\n\r\n/**\r\n * `Touchable`: Taps done right.\r\n *\r\n * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`\r\n * will measure time/geometry and tells you when to give feedback to the user.\r\n *\r\n * ====================== Touchable Tutorial ===============================\r\n * The `Touchable` mixin helps you handle the \"press\" interaction. It analyzes\r\n * the geometry of elements, and observes when another responder (scroll view\r\n * etc) has stolen the touch lock. It notifies your component when it should\r\n * give feedback to the user. (bouncing/highlighting/unhighlighting).\r\n *\r\n * - When a touch was activated (typically you highlight)\r\n * - When a touch was deactivated (typically you unhighlight)\r\n * - When a touch was \"pressed\" - a touch ended while still within the geometry\r\n *   of the element, and no other element (like scroller) has \"stolen\" touch\r\n *   lock (\"responder\") (Typically you bounce the element).\r\n *\r\n * A good tap interaction isn't as simple as you might think. There should be a\r\n * slight delay before showing a highlight when starting a touch. If a\r\n * subsequent touch move exceeds the boundary of the element, it should\r\n * unhighlight, but if that same touch is brought back within the boundary, it\r\n * should rehighlight again. A touch can move in and out of that boundary\r\n * several times, each time toggling highlighting, but a \"press\" is only\r\n * triggered if that touch ends while within the element's boundary and no\r\n * scroller (or anything else) has stolen the lock on touches.\r\n *\r\n * To create a new type of component that handles interaction using the\r\n * `Touchable` mixin, do the following:\r\n *\r\n * - Initialize the `Touchable` state.\r\n *\r\n *   getInitialState: function() {\r\n *     return merge(this.touchableGetInitialState(), yourComponentState);\r\n *   }\r\n *\r\n * - Choose the rendered component who's touches should start the interactive\r\n *   sequence. On that rendered node, forward all `Touchable` responder\r\n *   handlers. You can choose any rendered node you like. Choose a node whose\r\n *   hit target you'd like to instigate the interaction sequence:\r\n *\r\n *   // In render function:\r\n *   return (\r\n *     <View\r\n *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}\r\n *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}\r\n *       onResponderGrant={this.touchableHandleResponderGrant}\r\n *       onResponderMove={this.touchableHandleResponderMove}\r\n *       onResponderRelease={this.touchableHandleResponderRelease}\r\n *       onResponderTerminate={this.touchableHandleResponderTerminate}>\r\n *       <View>\r\n *         Even though the hit detection/interactions are triggered by the\r\n *         wrapping (typically larger) node, we usually end up implementing\r\n *         custom logic that highlights this inner one.\r\n *       </View>\r\n *     </View>\r\n *   );\r\n *\r\n * - You may set up your own handlers for each of these events, so long as you\r\n *   also invoke the `touchable*` handlers inside of your custom handler.\r\n *\r\n * - Implement the handlers on your component class in order to provide\r\n *   feedback to the user. See documentation for each of these class methods\r\n *   that you should implement.\r\n *\r\n *   touchableHandlePress: function() {\r\n *      this.performBounceAnimation();  // or whatever you want to do.\r\n *   },\r\n *   touchableHandleActivePressIn: function() {\r\n *     this.beginHighlighting(...);  // Whatever you like to convey activation\r\n *   },\r\n *   touchableHandleActivePressOut: function() {\r\n *     this.endHighlighting(...);  // Whatever you like to convey deactivation\r\n *   },\r\n *\r\n * - There are more advanced methods you can implement (see documentation below):\r\n *   touchableGetHighlightDelayMS: function() {\r\n *     return 20;\r\n *   }\r\n *   // In practice, *always* use a predeclared constant (conserve memory).\r\n *   touchableGetPressRectOffset: function() {\r\n *     return {top: 20, left: 20, right: 20, bottom: 100};\r\n *   }\r\n */\r\n\r\n/**\r\n * Touchable states.\r\n */\r\nvar States = {\r\n  NOT_RESPONDER: 'NOT_RESPONDER',\r\n  // Not the responder\r\n  RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',\r\n  // Responder, inactive, in the `PressRect`\r\n  RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',\r\n  // Responder, inactive, out of `PressRect`\r\n  RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',\r\n  // Responder, active, in the `PressRect`\r\n  RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',\r\n  // Responder, active, out of `PressRect`\r\n  RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\r\n  // Responder, active, in the `PressRect`, after long press threshold\r\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',\r\n  // Responder, active, out of `PressRect`, after long press threshold\r\n  ERROR: 'ERROR'\r\n};\r\n/**\r\n * Quick lookup map for states that are considered to be \"active\"\r\n */\r\n\r\nvar IsActive = {\r\n  RESPONDER_ACTIVE_PRESS_OUT: true,\r\n  RESPONDER_ACTIVE_PRESS_IN: true\r\n};\r\n/**\r\n * Quick lookup for states that are considered to be \"pressing\" and are\r\n * therefore eligible to result in a \"selection\" if the press stops.\r\n */\r\n\r\nvar IsPressingIn = {\r\n  RESPONDER_INACTIVE_PRESS_IN: true,\r\n  RESPONDER_ACTIVE_PRESS_IN: true,\r\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\r\n};\r\nvar IsLongPressingIn = {\r\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\r\n};\r\n/**\r\n * Inputs to the state machine.\r\n */\r\n\r\nvar Signals = {\r\n  DELAY: 'DELAY',\r\n  RESPONDER_GRANT: 'RESPONDER_GRANT',\r\n  RESPONDER_RELEASE: 'RESPONDER_RELEASE',\r\n  RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',\r\n  ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',\r\n  LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',\r\n  LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'\r\n};\r\n/**\r\n * Mapping from States x Signals => States\r\n */\r\n\r\nvar Transitions = {\r\n  NOT_RESPONDER: {\r\n    DELAY: States.ERROR,\r\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\r\n    RESPONDER_RELEASE: States.ERROR,\r\n    RESPONDER_TERMINATED: States.ERROR,\r\n    ENTER_PRESS_RECT: States.ERROR,\r\n    LEAVE_PRESS_RECT: States.ERROR,\r\n    LONG_PRESS_DETECTED: States.ERROR\r\n  },\r\n  RESPONDER_INACTIVE_PRESS_IN: {\r\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\r\n    RESPONDER_GRANT: States.ERROR,\r\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\r\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\r\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\r\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\r\n    LONG_PRESS_DETECTED: States.ERROR\r\n  },\r\n  RESPONDER_INACTIVE_PRESS_OUT: {\r\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\r\n    RESPONDER_GRANT: States.ERROR,\r\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\r\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\r\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\r\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\r\n    LONG_PRESS_DETECTED: States.ERROR\r\n  },\r\n  RESPONDER_ACTIVE_PRESS_IN: {\r\n    DELAY: States.ERROR,\r\n    RESPONDER_GRANT: States.ERROR,\r\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\r\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\r\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\r\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\r\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\r\n  },\r\n  RESPONDER_ACTIVE_PRESS_OUT: {\r\n    DELAY: States.ERROR,\r\n    RESPONDER_GRANT: States.ERROR,\r\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\r\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\r\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\r\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\r\n    LONG_PRESS_DETECTED: States.ERROR\r\n  },\r\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\r\n    DELAY: States.ERROR,\r\n    RESPONDER_GRANT: States.ERROR,\r\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\r\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\r\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\r\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\r\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\r\n  },\r\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\r\n    DELAY: States.ERROR,\r\n    RESPONDER_GRANT: States.ERROR,\r\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\r\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\r\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\r\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\r\n    LONG_PRESS_DETECTED: States.ERROR\r\n  },\r\n  error: {\r\n    DELAY: States.NOT_RESPONDER,\r\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\r\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\r\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\r\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\r\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\r\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\r\n  }\r\n}; // ==== Typical Constants for integrating into UI components ====\r\n// var HIT_EXPAND_PX = 20;\r\n// var HIT_VERT_OFFSET_PX = 10;\r\n\r\nvar HIGHLIGHT_DELAY_MS = 130;\r\nvar PRESS_EXPAND_PX = 20;\r\nvar LONG_PRESS_THRESHOLD = 500;\r\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\r\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10; // Default amount \"active\" region protrudes beyond box\r\n\r\n/**\r\n * By convention, methods prefixed with underscores are meant to be @private,\r\n * and not @protected. Mixers shouldn't access them - not even to provide them\r\n * as callback handlers.\r\n *\r\n *\r\n * ========== Geometry =========\r\n * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`\r\n * is an abstract box that is extended beyond the `HitRect`.\r\n *\r\n *  +--------------------------+\r\n *  |                          | - \"Start\" events in `HitRect` cause `HitRect`\r\n *  |  +--------------------+  |   to become the responder.\r\n *  |  |  +--------------+  |  | - `HitRect` is typically expanded around\r\n *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.\r\n *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,\r\n *  |  |  |              |  |  |   and before letting up, the Visual React\r\n *  |  |  +--------------+  |  |   will become \"active\". This makes it eligible\r\n *  |  |     HitRect        |  |   for being highlighted (so long as the\r\n *  |  +--------------------+  |   press remains in the `PressRect`).\r\n *  |        PressRect     o   |\r\n *  +----------------------|---+\r\n *           Out Region    |\r\n *                         +-----+ This gap between the `HitRect` and\r\n *                                 `PressRect` allows a touch to move far away\r\n *                                 from the original hit rect, and remain\r\n *                                 highlighted, and eligible for a \"Press\".\r\n *                                 Customize this via\r\n *                                 `touchableGetPressRectOffset()`.\r\n *\r\n *\r\n *\r\n * ======= State Machine =======\r\n *\r\n * +-------------+ <---+ RESPONDER_RELEASE\r\n * |NOT_RESPONDER|\r\n * +-------------+ <---+ RESPONDER_TERMINATED\r\n *     +\r\n *     | RESPONDER_GRANT (HitRect)\r\n *     v\r\n * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+\r\n * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|\r\n * +---------------------------+          +-------------------------+                +------------------------------+\r\n *     +            ^                         +           ^                                 +           ^\r\n *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_\r\n *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT\r\n *     |            |                         |           |                                 |           |\r\n *     v            +                         v           +                                 v           +\r\n * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+\r\n * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|\r\n * +----------------------------+         +--------------------------+               +-------------------------------+\r\n *\r\n * T + DELAY => LONG_PRESS_DELAY_MS + DELAY\r\n *\r\n * Not drawn are the side effects of each transition. The most important side\r\n * effect is the `touchableHandlePress` abstract method invocation that occurs\r\n * when a responder is released while in either of the \"Press\" states.\r\n *\r\n * The other important side effects are the highlight abstract method\r\n * invocations (internal callbacks) to be implemented by the mixer.\r\n *\r\n *\r\n * @lends Touchable.prototype\r\n */\r\n\r\nvar TouchableMixin = {\r\n  // HACK (part 1): basic support for touchable interactions using a keyboard\r\n  componentDidMount: function componentDidMount() {\r\n    var _this = this;\r\n\r\n    this._touchableNode = findNodeHandle(this);\r\n\r\n    if (this._touchableNode && this._touchableNode.addEventListener) {\r\n      this._touchableBlurListener = function (e) {\r\n        if (_this._isTouchableKeyboardActive) {\r\n          if (_this.state.touchable.touchState && _this.state.touchable.touchState !== States.NOT_RESPONDER) {\r\n            _this.touchableHandleResponderTerminate({\r\n              nativeEvent: e\r\n            });\r\n          }\r\n\r\n          _this._isTouchableKeyboardActive = false;\r\n        }\r\n      };\r\n\r\n      this._touchableNode.addEventListener('blur', this._touchableBlurListener);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear all timeouts on unmount\r\n   */\r\n  componentWillUnmount: function componentWillUnmount() {\r\n    if (this._touchableNode && this._touchableNode.addEventListener) {\r\n      this._touchableNode.removeEventListener('blur', this._touchableBlurListener);\r\n    }\r\n\r\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\r\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\r\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\r\n  },\r\n\r\n  /**\r\n   * It's prefer that mixins determine state in this way, having the class\r\n   * explicitly mix the state in the one and only `getInitialState` method.\r\n   *\r\n   * @return {object} State object to be placed inside of\r\n   * `this.state.touchable`.\r\n   */\r\n  touchableGetInitialState: function touchableGetInitialState() {\r\n    return {\r\n      touchable: {\r\n        touchState: undefined,\r\n        responderID: null\r\n      }\r\n    };\r\n  },\r\n  // ==== Hooks to Gesture Responder system ====\r\n\r\n  /**\r\n   * Must return true if embedded in a native platform scroll view.\r\n   */\r\n  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {\r\n    return !this.props.rejectResponderTermination;\r\n  },\r\n\r\n  /**\r\n   * Must return true to start the process of `Touchable`.\r\n   */\r\n  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {\r\n    return !this.props.disabled;\r\n  },\r\n\r\n  /**\r\n   * Return true to cancel press on long press.\r\n   */\r\n  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Place as callback for a DOM element's `onResponderGrant` event.\r\n   */\r\n  touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {\r\n    var dispatchID = e.currentTarget; // Since e is used in a callback invoked on another event loop\r\n    // (as in setTimeout etc), we need to call e.persist() on the\r\n    // event to make sure it doesn't get reused in the event object pool.\r\n\r\n    e.persist();\r\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\r\n    this.pressOutDelayTimeout = null;\r\n    this.state.touchable.touchState = States.NOT_RESPONDER;\r\n    this.state.touchable.responderID = dispatchID;\r\n\r\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\r\n\r\n    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\r\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\r\n\r\n    if (delayMS !== 0) {\r\n      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);\r\n    } else {\r\n      this.state.touchable.positionOnActivate = null;\r\n\r\n      this._handleDelay(e);\r\n    }\r\n\r\n    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\r\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\r\n    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);\r\n  },\r\n\r\n  /**\r\n   * Place as callback for a DOM element's `onResponderRelease` event.\r\n   */\r\n  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {\r\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\r\n  },\r\n\r\n  /**\r\n   * Place as callback for a DOM element's `onResponderTerminate` event.\r\n   */\r\n  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {\r\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\r\n  },\r\n\r\n  /**\r\n   * Place as callback for a DOM element's `onResponderMove` event.\r\n   */\r\n  touchableHandleResponderMove: function touchableHandleResponderMove(e) {\r\n    // Not enough time elapsed yet, wait for highlight -\r\n    // this is just a perf optimization.\r\n    if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {\r\n      return;\r\n    } // Measurement may not have returned yet.\r\n\r\n\r\n    if (!this.state.touchable.positionOnActivate) {\r\n      return;\r\n    }\r\n\r\n    var positionOnActivate = this.state.touchable.positionOnActivate;\r\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\r\n    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {\r\n      left: PRESS_EXPAND_PX,\r\n      right: PRESS_EXPAND_PX,\r\n      top: PRESS_EXPAND_PX,\r\n      bottom: PRESS_EXPAND_PX\r\n    };\r\n    var pressExpandLeft = pressRectOffset.left;\r\n    var pressExpandTop = pressRectOffset.top;\r\n    var pressExpandRight = pressRectOffset.right;\r\n    var pressExpandBottom = pressRectOffset.bottom;\r\n    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;\r\n\r\n    if (hitSlop) {\r\n      pressExpandLeft += hitSlop.left;\r\n      pressExpandTop += hitSlop.top;\r\n      pressExpandRight += hitSlop.right;\r\n      pressExpandBottom += hitSlop.bottom;\r\n    }\r\n\r\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\r\n    var pageX = touch && touch.pageX;\r\n    var pageY = touch && touch.pageY;\r\n\r\n    if (this.pressInLocation) {\r\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\r\n\r\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\r\n        this._cancelLongPressDelayTimeout();\r\n      }\r\n    }\r\n\r\n    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;\r\n\r\n    if (isTouchWithinActive) {\r\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\r\n\r\n      var curState = this.state.touchable.touchState;\r\n\r\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {\r\n        // fix for t7967420\r\n        this._cancelLongPressDelayTimeout();\r\n      }\r\n    } else {\r\n      this._cancelLongPressDelayTimeout();\r\n\r\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\r\n    }\r\n  },\r\n  // ==== Abstract Application Callbacks ====\r\n\r\n  /**\r\n   * Invoked when the item should be highlighted. Mixers should implement this\r\n   * to visually distinguish the `VisualRect` so that the user knows that\r\n   * releasing a touch will result in a \"selection\" (analog to click).\r\n   *\r\n   * @abstract\r\n   * touchableHandleActivePressIn: function,\r\n   */\r\n\r\n  /**\r\n   * Invoked when the item is \"active\" (in that it is still eligible to become\r\n   * a \"select\") but the touch has left the `PressRect`. Usually the mixer will\r\n   * want to unhighlight the `VisualRect`. If the user (while pressing) moves\r\n   * back into the `PressRect` `touchableHandleActivePressIn` will be invoked\r\n   * again and the mixer should probably highlight the `VisualRect` again. This\r\n   * event will not fire on an `touchEnd/mouseUp` event, only move events while\r\n   * the user is depressing the mouse/touch.\r\n   *\r\n   * @abstract\r\n   * touchableHandleActivePressOut: function\r\n   */\r\n\r\n  /**\r\n   * Invoked when the item is \"selected\" - meaning the interaction ended by\r\n   * letting up while the item was either in the state\r\n   * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.\r\n   *\r\n   * @abstract\r\n   * touchableHandlePress: function\r\n   */\r\n\r\n  /**\r\n   * Invoked when the item is long pressed - meaning the interaction ended by\r\n   * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If\r\n   * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will\r\n   * be called as it normally is. If `touchableHandleLongPress` is provided, by\r\n   * default any `touchableHandlePress` callback will not be invoked. To\r\n   * override this default behavior, override `touchableLongPressCancelsPress`\r\n   * to return false. As a result, `touchableHandlePress` will be called when\r\n   * lifting up, even if `touchableHandleLongPress` has also been called.\r\n   *\r\n   * @abstract\r\n   * touchableHandleLongPress: function\r\n   */\r\n\r\n  /**\r\n   * Returns the number of millis to wait before triggering a highlight.\r\n   *\r\n   * @abstract\r\n   * touchableGetHighlightDelayMS: function\r\n   */\r\n\r\n  /**\r\n   * Returns the amount to extend the `HitRect` into the `PressRect`. Positive\r\n   * numbers mean the size expands outwards.\r\n   *\r\n   * @abstract\r\n   * touchableGetPressRectOffset: function\r\n   */\r\n  // ==== Internal Logic ====\r\n\r\n  /**\r\n   * Measures the `HitRect` node on activation. The Bounding rectangle is with\r\n   * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`\r\n   * should result in points that are in the same coordinate system as an\r\n   * event's `globalX/globalY` data values.\r\n   *\r\n   * - Consider caching this for the lifetime of the component, or possibly\r\n   *   being able to share this cache between any `ScrollMap` view.\r\n   *\r\n   * @sideeffects\r\n   * @private\r\n   */\r\n  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {\r\n    var tag = this.state.touchable.responderID;\r\n\r\n    if (tag == null) {\r\n      return;\r\n    }\r\n\r\n    UIManager.measure(tag, this._handleQueryLayout);\r\n  },\r\n  _handleQueryLayout: function _handleQueryLayout(x, y, width, height, globalX, globalY) {\r\n    // don't do anything if UIManager failed to measure node\r\n    if (!x && !y && !width && !height && !globalX && !globalY) {\r\n      return;\r\n    }\r\n\r\n    this.state.touchable.positionOnActivate && Position.release(this.state.touchable.positionOnActivate);\r\n    this.state.touchable.dimensionsOnActivate && // $FlowFixMe\r\n    BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);\r\n    this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY); // $FlowFixMe\r\n\r\n    this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(width, height);\r\n  },\r\n  _handleDelay: function _handleDelay(e) {\r\n    this.touchableDelayTimeout = null;\r\n\r\n    this._receiveSignal(Signals.DELAY, e);\r\n  },\r\n  _handleLongDelay: function _handleLongDelay(e) {\r\n    this.longPressDelayTimeout = null;\r\n    var curState = this.state.touchable.touchState;\r\n\r\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\r\n      console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\r\n    } else {\r\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Receives a state machine signal, performs side effects of the transition\r\n   * and stores the new state. Validates the transition as well.\r\n   *\r\n   * @param {Signals} signal State machine signal.\r\n   * @throws Error if invalid state transition or unrecognized signal.\r\n   * @sideeffects\r\n   */\r\n  _receiveSignal: function _receiveSignal(signal, e) {\r\n    var responderID = this.state.touchable.responderID;\r\n    var curState = this.state.touchable.touchState;\r\n    var nextState = Transitions[curState] && Transitions[curState][signal];\r\n\r\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\r\n      return;\r\n    }\r\n\r\n    if (!nextState) {\r\n      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');\r\n    }\r\n\r\n    if (nextState === States.ERROR) {\r\n      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');\r\n    }\r\n\r\n    if (curState !== nextState) {\r\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\r\n\r\n      this.state.touchable.touchState = nextState;\r\n    }\r\n  },\r\n  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {\r\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\r\n    this.longPressDelayTimeout = null;\r\n  },\r\n  _isHighlight: function _isHighlight(state) {\r\n    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\r\n  },\r\n  _savePressInLocation: function _savePressInLocation(e) {\r\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\r\n    var pageX = touch && touch.pageX;\r\n    var pageY = touch && touch.pageY;\r\n    this.pressInLocation = {\r\n      pageX: pageX,\r\n      pageY: pageY,\r\n\r\n      get locationX() {\r\n        return touch && touch.locationX;\r\n      },\r\n\r\n      get locationY() {\r\n        return touch && touch.locationY;\r\n      }\r\n\r\n    };\r\n  },\r\n  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\r\n    var deltaX = aX - bX;\r\n    var deltaY = aY - bY;\r\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n  },\r\n\r\n  /**\r\n   * Will perform a transition between touchable states, and identify any\r\n   * highlighting or unhighlighting that must be performed for this particular\r\n   * transition.\r\n   *\r\n   * @param {States} curState Current Touchable state.\r\n   * @param {States} nextState Next Touchable state.\r\n   * @param {Signal} signal Signal that triggered the transition.\r\n   * @param {Event} e Native event.\r\n   * @sideeffects\r\n   */\r\n  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {\r\n    var curIsHighlight = this._isHighlight(curState);\r\n\r\n    var newIsHighlight = this._isHighlight(nextState);\r\n\r\n    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\r\n\r\n    if (isFinalSignal) {\r\n      this._cancelLongPressDelayTimeout();\r\n    }\r\n\r\n    if (!IsActive[curState] && IsActive[nextState]) {\r\n      this._remeasureMetricsOnActivation();\r\n    }\r\n\r\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\r\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\r\n    }\r\n\r\n    if (newIsHighlight && !curIsHighlight) {\r\n      this._startHighlight(e);\r\n    } else if (!newIsHighlight && curIsHighlight) {\r\n      this._endHighlight(e);\r\n    }\r\n\r\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\r\n      var hasLongPressHandler = !!this.props.onLongPress;\r\n      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && ( // We *are* long pressing..\r\n      !hasLongPressHandler || // But either has no long handler\r\n      !this.touchableLongPressCancelsPress()); // or we're told to ignore it.\r\n\r\n      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\r\n\r\n      if (shouldInvokePress && this.touchableHandlePress) {\r\n        if (!newIsHighlight && !curIsHighlight) {\r\n          // we never highlighted because of delay, but we should highlight now\r\n          this._startHighlight(e);\r\n\r\n          this._endHighlight(e);\r\n        }\r\n\r\n        this.touchableHandlePress(e);\r\n      }\r\n    }\r\n\r\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\r\n    this.touchableDelayTimeout = null;\r\n  },\r\n  _startHighlight: function _startHighlight(e) {\r\n    this._savePressInLocation(e);\r\n\r\n    this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\r\n  },\r\n  _endHighlight: function _endHighlight(e) {\r\n    var _this2 = this;\r\n\r\n    if (this.touchableHandleActivePressOut) {\r\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\r\n        this.pressOutDelayTimeout = setTimeout(function () {\r\n          _this2.touchableHandleActivePressOut(e);\r\n        }, this.touchableGetPressOutDelayMS());\r\n      } else {\r\n        this.touchableHandleActivePressOut(e);\r\n      }\r\n    }\r\n  },\r\n  // HACK (part 2): basic support for touchable interactions using a keyboard (including\r\n  // delays and longPress)\r\n  touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {\r\n    var ENTER = 13;\r\n    var SPACE = 32;\r\n    var type = e.type,\r\n        which = e.which;\r\n\r\n    if (which === ENTER || which === SPACE) {\r\n      if (type === 'keydown') {\r\n        if (!this._isTouchableKeyboardActive) {\r\n          if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {\r\n            this.touchableHandleResponderGrant(e);\r\n            this._isTouchableKeyboardActive = true;\r\n          }\r\n        }\r\n      } else if (type === 'keyup') {\r\n        if (this._isTouchableKeyboardActive) {\r\n          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {\r\n            this.touchableHandleResponderRelease(e);\r\n            this._isTouchableKeyboardActive = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      e.stopPropagation(); // prevent the default behaviour unless the Touchable functions as a link\r\n      // and Enter is pressed\r\n\r\n      if (!(which === ENTER && AccessibilityUtil.propsToAriaRole(this.props) === 'link')) {\r\n        e.preventDefault();\r\n      }\r\n    }\r\n  }\r\n};\r\nvar Touchable = {\r\n  Mixin: TouchableMixin,\r\n  TOUCH_TARGET_DEBUG: false,\r\n  // Highlights all touchable targets. Toggle with Inspector.\r\n\r\n  /**\r\n   * Renders a debugging overlay to visualize touch target with hitSlop (might not work on Android).\r\n   */\r\n  renderDebugView: function renderDebugView(_ref) {\r\n    var color = _ref.color,\r\n        hitSlop = _ref.hitSlop;\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (!Touchable.TOUCH_TARGET_DEBUG) {\r\n        return null;\r\n      }\r\n\r\n      var debugHitSlopStyle = {};\r\n      hitSlop = hitSlop || {\r\n        top: 0,\r\n        bottom: 0,\r\n        left: 0,\r\n        right: 0\r\n      };\r\n\r\n      for (var key in hitSlop) {\r\n        debugHitSlopStyle[key] = -hitSlop[key];\r\n      }\r\n\r\n      var hexColor = '#' + ('00000000' + normalizeColor(color).toString(16)).substr(-8);\r\n      return React.createElement(View, {\r\n        pointerEvents: \"none\",\r\n        style: _objectSpread({\r\n          position: 'absolute',\r\n          borderColor: hexColor.slice(0, -2) + '55',\r\n          // More opaque\r\n          borderWidth: 1,\r\n          borderStyle: 'dashed',\r\n          backgroundColor: hexColor.slice(0, -2) + '0F'\r\n        }, debugHitSlopStyle)\r\n      });\r\n    }\r\n  }\r\n};\r\nexport default Touchable;"]},"metadata":{},"sourceType":"module"}